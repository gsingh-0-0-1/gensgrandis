<!-- Copyright (C) Gurmehar Singh 2020 - All Rights Reserved
/* Unauthorized copying or distribution of this file, via any medium is strictly prohibited
/* Proprietary and confidential
/* Written by Gurmehar Singh <gurmehar@gmail.com>
/-->


<!DOCTYPE html>
<html lang="en">
<head>
	<title>GÄ“ns Grandis</title>
	<style type="text/css">

		gui {
			position: fixed;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
		}
		body {
			background-color: #000;
		}

		.button {
			border: none;
			color: white;
			padding: 15px 24px;
			text-align: center;
			display: inline-block;
			margin: 4px 2px;
			cursor: pointer;
		}

		.button:focus{
			outline: none;
		}

		.city_name_input:focus{
			outline: none;
		}

		.city_sidebar_small_cont{
			position: relative;
			width: 50%; 
			height: 15px; 
			color: #daa; 
			font-family: Courier; 
			font-size: 18px
		}

		.tutorialpanel{
			position: fixed; 
			left: 50%; 
			top: 5%; 
			transform: 
			translate(-50%, 0%); 
			width: 20%; 
			height: 15%; 
			background-color: #4a4aaa; 
			z-index: 2; 
			border: 2px solid #999; 
			font-size: 20px; 
			color: #bbb; 
			text-align: center; 
			font-family: Courier; 
			padding: 10px 10px; 
			display: none
		}
	</style>
</head>
<body>

	<!--
	Template for a tile on the tile-view for cities
	-->
	<input type="button" id="tiletemplate" style="position: fixed; left: 0px; top: 0px; width: 100px; height: 100px; transform: translate(-50%, -50%); background-color: #3a3; display: initial; z-index: 0; box-sizing: border-box" onclick="javascript:selectTileFromTileView(this)">

	<gui id="gui" style="z-index: 1;">
	</gui>

	<div id="loadingscreen" style="position: fixed; left: 0%; top: 0%; width: 100%; height: 100%; background-color: #000; text-align: center; color: #ddd; font-family: 'Times New Roman'; z-index: 3">
		<div style="position: relative; top: 50%; font-size: 50px">
			Waiting for your turn...
		</div>
	</div>

	<div id="unit_desc" style="position: fixed; left: 0%; top: 75%; width: 30%; height: 25%; background-color: #4a4aaa; border-top: 5px solid #d9d0d0; border-right: 5px solid #d9d0d0; box-sizing: border-box; z-index: 0; display: none">
		<div id="unit_desc_name" style="position: relative; left: 6%; top: 10%; font-family: Verdana; font-size: 20px; color: #ffffff">
		</div>
		<div id="unit_desc_x" style="position: relative; left: 10%; top: 18%; font-family: Verdana; font-size: 20px; color: #ffffff">
		</div>
		<div id="unit_desc_y" style="position: relative; left: 10%; top: 20%; font-family: Verdana; font-size: 20px; color: #ffffff">
		</div>
		<div id="unit_desc_m" style="position: relative; left: 10%; top: 22%; font-family: Verdana; font-size: 20px; color: #ffffff">
		</div>
		<div id="unit_desc_status" style="position: relative; left: 10%; top: 25%; font-family: Verdana; font-size: 20px; color: #ffffff">
		</div>
	</div>


	<div id="unit_commands_info" style="position: fixed; left: 50%; top: 90%; width: 40%; height: 20%; transform: translate(-50%, -50%); background-color: #4a4aaa; border: 5px solid #d9d0d0; box-sizing: border-box; display: none; z-index: 0; font-family: Courier; font-size: 18px; color: #daa;">
		<div id="general_commands" style="position: fixed; left: 3%; top: 10%;">
			G: Moving Mode 
			<br>
			&nbsp;&nbsp;Click on tile to move
			<br>
			ESC: Deselect Unit
		</div>

		<div id="unit_specific_commands" style="position: fixed; left: 53%; top: 10%">
		</div>

		<div id="endturn_info" style="position: fixed; left: 50%; top: 65%; transform: translate(-50%, 0)">
			T to End Turn
		</div>
	</div>


	<div id="city_info_sidebar" style="position: fixed; left: 80%; top: 0%; width: 20%; height: 100%; background-color: #4a4aaa; border: 5px solid #d9b0b0; box-sizing: border-box; z-index: 0; display: none;">

		<div id="city_info_sidebar_name" style="position: relative; left: 5%; top: 2%; color: #ddd; font-family: Verdana; font-size: 15px; border-bottom: 2px solid white; height: 20px; width: 80%">
		</div>

		<div id="city_info_sidebar_center_loc" class="city_sidebar_small_cont" style="top: 5%; left: 7%">
			Center Location:

			<div id="city_info_sidebar_center_loc_x" style="padding-left: 20px">
			</div>

			<div id="city_info_sidebar_center_loc_y" style="padding-left: 20px">
			</div>
		</div>

		<div id="city_info_sidebar_selected_loc" class="city_sidebar_small_cont" style="top: 12%; left: 7%">
			Selected Tile:

			<div id="city_info_sidebar_selected_loc_x" style="padding-left: 20px">
			</div>

			<div id="city_info_sidebar_selected_loc_y" style="padding-left: 20px">
			</div>	

			<div id="city_info_sidebar_selected_pop" style="padding-left: 20px">
			</div>

			<div id="city_info_sidebar_selected_food" style="padding-left: 20px">
			</div>

		</div>

		<div id="city_info_sidebar_expand" class="city_sidebar_small_cont" style="top: 23%; left: 7%">
			Expand City...

			<br><br>

			<div id="city_info_sidebar_selected_loc_x" style="padding-left: 20px">

				&nbsp;&nbsp;
				<table>

					<tr>
						<td></td>
						<td>
							<input class="button" type="button" value="N" style="font-size: 16px; font-family: Courier; background-color: #8c1a1a; padding: 5px 5px" onclick="javascript:expandCity([0, 1])">
						</td>
						<td></td>
					</tr>

					<tr>
						<td>
							<input class="button" type="button" value="W" style="font-size: 16px; font-family: Courier;background-color: #8c8c1a; padding: 5px 5px" onclick="javascript:expandCity([-1, 0])">
						</td>
						<td></td>
						<td>
							<input class="button" type="button" value="E" style="font-size: 16px; font-family: Courier;background-color: #1a1a8c; padding: 5px 5px" onclick="javascript:expandCity([1, 0])">	
						</td>
					</tr>
					<tr>
						<td></td>
						<td>
							<input class="button" type="button" value="S" style="font-size: 16px; font-family: Courier;background-color: #1a8c1a; padding: 5px 5px" onclick="javascript:expandCity([0, -1])">
						</td>
						<td></td>
					</tr>
				</table>

			</div>

		</div>

		<div id="city_info_sidebar_breakoff_people" class="city_sidebar_small_cont" style="top: 45%; left: 7%">
			Break city off into people...

			<div style="padding-left: 20px">

				<input class="button" type="button" value="Break >>" style="font-size: 16px; font-family: Courier;background-color: #111; padding: 5px 5px" onclick="javascript:breakCity()">

			</div>

		</div>

		<div id="city_info_sidebar_view_city_tiles" class="city_sidebar_small_cont" style="top: 55%; left: 7%">
			View city...

			<div style="padding-left: 20px">

				<input class="button" type="button" value="View >>" style="font-size: 16px; font-family: Courier;background-color: #040; padding: 5px 5px" onclick="javascript:showCityTileView()">

			</div>

		</div>

		<div id="city_info_sidebar_redirect_food" class="city_sidebar_small_cont" style="top: 65%; left: 7%">
			Redirect food...

			<div style="padding-left: 20px">

				<input class="button" type="button" value="Redirect >>" style="font-size: 16px; font-family: Courier;background-color: #400; padding: 5px 5px" onclick="javascript:redirectFood()">
				<input class="button" type="text" style="font-size: 16px; font-family: Courier;background-color: #aae; padding: 5px 5px; color: #111" id="foodRedirectTextInput" placeholder="--Redirect amount--">

			</div>			

		</div>

		<div id="city_info_sidebar_produce_unit" class="city_sidebar_small_cont" style="top: 75%; left: 7%">
			Produce unit...

			<select id="select_unit_to_produce">
				<option value="">-Select a unit-</option>
				<option value="RB">Riverboat</option>
			</select>

			<button id="producebutton" onclick="javascript:changeCityProduction()">Produce</button>

			<br>

			[ <span id="city_info_sidebar_people_turns"></span> / <span id="city_info_sidebar_prod_target"></span> ] -- <span id="city_info_sidebar_prod_unit"></span>

		</div>

	</div>

	<div id="city_name_input_container" style="position: fixed; left: 75%; top: 5%; width: 20%; height: 15%; background-color: #4a4aaa; z-index: 0; color: #ddd; font-family: Verdana; font-size: 17px; display: none; border: 2px solid #aaaac5">
		<div style="position: relative; top: 10%; left: 5%;">
			Enter a name for this city:
		</div>
		<input type="text" id="city_name_input_box" class="city_name_input" style="position: relative; background-color: rgba(255, 255, 255, 0); border: none; border-bottom: 2px solid white; top: 40%; left: 10%; color: #ddd" onkeypress="javascript:handleCityNameInput(event)" maxlength="20">

		<input type="hidden" id="city_naming_id">
	</div>

	<div id="city_tile_view_screen" style="position: fixed; left: 50%; top: 50%; width: 50%; height: 50%; transform: translate(-50%, -50%); z-index: 0; display: initial; background-color: #333; border: 10px solid #bbb; overflow: scroll">
	</div>

	<div id="tutorial_ask" class="tutorialpanel">
		Welcome to singleplayer! Would you like to start the tutorial?
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Yes" onclick="javascript:startTutorial()">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="No" onclick="javascript:hideTutorialAsk()">
	</div>


	<div id="tutorial_1" class="tutorialpanel">
		You've just spawned into the game - and you have one "People" unit. Try clicking on it - it should light up and you'll see some info in the bottom left corner of the screen.

		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>


	<div id="tutorial_2" class="tutorialpanel">
		To move your camera around, use the arrow keys. To move up and down, use SPACE and "Z". Also, you're currently looking north - to look south, use "S", and to look back north, use "W".
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>


	<div id="tutorial_3" class="tutorialpanel">
		Great! Now, press the "G" key. You should see that the unit is now in "moving" mode. Click on any of the 8 tiles around the unit to move the unit to that tile.

		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_4" class="tutorialpanel">
		When you moved the unit, you might have noticed that the "Movement" of the unit decreased by 1. You have a limited amount of movement each "turn" for each unit.

		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_5" class="tutorialpanel">
		Keep exploring around until your unit's movement runs out. When that happens, press "T" to end your turn. Also, take a look at the bottom-center panel for some more info.

		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_6" class="tutorialpanel">
		Now that you've got the basics of unit movement down, select your unit again if you don't already have it selected. Press "B" to build a city, and name it whatever you'd like.

		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_7" class="tutorialpanel">
		Go ahead and click your city tile. You should see a sidebar pop up on the right - let's go through it together.
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_8" class="tutorialpanel">
		The first few lines should be self-explanatory - they show the location of the center of the selected city, the location of the selected tile, and the tile's population and food.
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_9" class="tutorialpanel">
		The population of any tile will grow up to just about the amount of food it has - no more. Grass tiles have a good amount of food, forest tiles have less. Tiles next to water have more food, and tiles on higher elevations have less food.
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 73%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 73%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_10" class="tutorialpanel">
		Below those details, you'll see a menu called "Expand City". If, on any tile, you have 100 or more people, 50 of those people can move to an adjacent tile, leaving 50 or more behind. Try it!
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_11" class="tutorialpanel">
		Next, you'll see a button called "Break >>". If you have 150 or more people on a tile, this button takes 100 of those people to create another "People" unit. You can use this unit to explore or create more cities.
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 75%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 75%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_12" class="tutorialpanel">
		And lastly, you'll see the "View >>" and "Redirect >>" buttons. Go ahead and click on the "View >>" button - it'll show you a 2-D view of the tiles in your currently selected city. Hit ESC to close the view.
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>


	<div id="tutorial_13" class="tutorialpanel">
		Now, say your city has some tiles with a lot of food, but you want to expand elsewhere. You can redirect food from one tile to another. First, select the tile that you want to take food from.
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_14" class="tutorialpanel">
		Type the amount of food you want to redirect into the text box below the "Redirect >>" button. Click the "Redirect >>" button - it'll open up the 2-D view. Here, select the tile that you want to redirect the food to.
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 75%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 75%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_15" class="tutorialpanel">
		Hit ESC to close the 2-D view. You should see the sidebar update for the tile you initially selected, and if you click on the tile that you redirected food to, you should see that it has more food now.
		<input class="button" type="button" style="position: fixed; background-color: #88b488; color: #555; font-family: Courier; top: 65%; left: 40%; transform: translate(-50%, 0%); padding: 7px 7px" value="Continue" onclick="javascript:nextTutorial(this)">

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 65%; left: 60%; transform: translate(-50%, 0%); padding: 7px 7px" value="Exit" onclick="javascript:endTutorial(this)">

	</div>

	<div id="tutorial_16" class="tutorialpanel">
		That's it for now! If that was a lot of info, don't worry - you'll get the hang of it soon enough. If you have any questions, you can find the link to our discord on the home page. Thanks for playing!

		<input class="button" type="button" style="position: fixed; background-color: #b48888; color: #555; font-family: Courier; top: 75%; left: 50%; transform: translate(-50%, 0%); padding: 7px 7px" value="Close" onclick="javascript:endTutorial(this)">

	</div>

</body>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.js"></script>
<script type="text/javascript" src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

<script src="http://mrdoob.github.com/three.js/examples/js/postprocessing/EffectComposer.js"></script>
<script src="http://mrdoob.github.com/three.js/examples/js/postprocessing/RenderPass.js"></script>
<script src="http://mrdoob.github.com/three.js/examples/js/postprocessing/MaskPass.js"></script>
<script src="http://mrdoob.github.com/three.js/examples/js/postprocessing/ShaderPass.js"></script>
<script src="http://mrdoob.github.com/three.js/examples/js/shaders/CopyShader.js"></script>
<script src="https://threejs.org/examples/js/postprocessing/OutlinePass.js"></script>

<script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"></script>

<script src="/templates/colors.js"></script>
<script src="/templates/utils.js"></script>
<script src="/templates/tutorial.js"></script>

<script src="/templates/socket.io.js"></script>

<script>

	var socket = io(window.location.pathname);

	var multi = false

	if (window.location.pathname.includes("gameroom")){
		multi = true
	}

	if (!multi){
		showTutorialAsk()
	}

	//****************************************************************************************//
	//******************************CONSTANTS AND INITIALIZATION******************************//
	//****************************************************************************************//
	const leftarrowcode = 37
	const uparrowcode = 38
	const rightarrowcode = 39
	const downarrowcode = 40
	const spacekeycode = 32
	const shiftkeycode = 16
	const akeycode = 65
	const dkeycode = 68
	const esckeycode = 27
	const endturnkeycode = 84
	const enterkeycode = 13

	var unit_corresponds = {"P" : "People", 
							"RB" : "Riverboat"}
	var unit_movements = {"P" : 5, "RB" : 10}
	var unit_commands = {"P" : "B: Build city",
						"RB" : ""}

	var unit_produce_times = {"RB" : 1200}

	var unit_z_offsets = {"P" : 0.7,
						"RB" : 0}

	//unit templates
	var people_template = "P~x:xhere,y:yhere,n:100,m:" + unit_movements["P"]
	var riverboat_template = "RB~x:xhere,y:yhere,m:" + unit_movements["RB"]

	var moving_unit = false;
	var expanding_city = false;

	var unit_z_offset = 0.7

	var mincitytilepop = 50

	var city_tile_hut_locs = [[0, 0], 
								[0.2, 0.1], 
								[0, 0.1], 
								[-0.1, 0.15], 
								[-0.1, -0.1], 
								[0.1, 0],
								[-0.2, 0.1],
								[0.1, -0.1],
								[0.2, -0.22],
								[0.3, -0.2]]
	var MAX_CITY_TILE_SIZE = 6
	var TILE_POP_STEP = 100

	var urlParams = new URLSearchParams(window.location.search);
	const GAMEID = urlParams.get("gameid")
	/*var ACCESSCODE = urlParams.get("accesscode")
	var ACSTRING = "accesscode=" + ACCESSCODE*/

	const LAND_TILE_CODE = 'l'

	const FOREST_START_TILE_CODE = 's,l,f'
	const FOREST_TILE_CODE = 'l,f'

	const MOUNTAIN_START_TILE_CODE = 's,l,m'
	const MOUNTAIN_TILE_CODE = 'l,m'

	const WATER_BODY_START_TILE_CODE = 's,w,l,n'
	const WATER_BODY_TILE_CODE = 'w,l,n'

	const RIVER_START_TILE_CODE = 's,w,l,r'
	const RIVER_TILE_CODE = 'w,r'

	const HEIGHT_DELIMITER = "#"
	const INFO_DELIMITER = "|"

	const WORLD_RAD = 500

	var WORLD_SEED = 0

	var activetiles = []
	var exploredtiles = 'null'
	var units = []

	var LOAD_TERRAIN_DIST = 2

	var MOUNTAIN_FOREST_HEIGHT = 1
	var MOUNTAIN_STONE_HEIGHT = 5
	var MOUNTAIN_SNOWCAP_HEIGHT = 6
	var MOUNTAIN_SNOW_HEIGHT = 8.5

	var FILE = "map1"


	const leaves_material = new THREE.MeshBasicMaterial( {color: 0x116611} );

	var cameralooking = 'front'

	var gamecenterx = 550
	var gamecentery = 555

	var camerainitx = gamecenterx
	var camerainity = gamecentery
	var camerainitz = 5

	const ground_z = -2
	const base_tile_height = 0

	var grid_dict = {}

	//****************************************************************************************//
	//****************************************************************************************//
	//****************************************************************************************//





	//********************************************************************************//
	//******************************BASIC GAME FUNCTIONS******************************//
	//********************************************************************************//

	function drawTree(coords, tileheight, num){
		var i = coords[0]
		var j = coords[1]

		var xoff = (( Math.pow(tileheight + num*j, num) * WORLD_SEED * i * j) % 2000) - 1000
		var yoff = (( Math.pow(tileheight + num*i, num) * WORLD_SEED / i / j) % 2000) - 1000

		xoff /= 2000
		yoff /= 2000

		var rad = 0.05
		var height = 0.2

		var trunkheight = height * 0.2
		var trunkrad = rad * 0.5

		var leavesheight = height// * 0.8
		var leavesrad = rad

		/*var trunk_geometry = new THREE.CylinderGeometry(trunkrad, trunkrad, trunkheight, 8)
		var trunk_material = new THREE.MeshBasicMaterial( {color: 0x654321} )
		var trunk = new THREE.Mesh( trunk_geometry, trunk_material)*/

		var leaves_geometry = new THREE.BufferGeometry().fromGeometry(new THREE.ConeGeometry( leavesrad, leavesheight, 3 ));
		var leaves = new THREE.Mesh( leaves_geometry, leaves_material );

		//trunk.add(leaves)
		//leaves.position.set(0, trunkheight / 2 + leavesheight / 2, 0)

		//var tree = trunk

		//tile.add(trunk);
		//tile.add(leaves)
		var z_offset = 0
		//check for mountain / elevated tiles
		/*if (tile.geometry.parameters.depth != undefined){
			z_offset = tile.geometry.parameters.depth / 2
		}*/

		//leaves.position.set(i + xoff, j + yoff, (ground_z + height/2 + tileheight) )
		leaves.position.set(xoff, yoff, tileheight / 2 + height / 2)
		leaves.rotation.set(Math.PI/2, 0, 0)
		leaves.tree = true
		tile = getTileAt(i, j)
		tile.add(leaves)
		//scene.add(leaves)
	}

	function getTileAt(x, y){
		//return scene.getObjectByName("tile_" + coords[0] + "_" + coords[1]) 
		return grid_dict["tile_" + x + "_" + y]
	}

	function checkValidTile(coords){
		if ((Math.abs(coords[0]) <= 2 * WORLD_RAD) && (Math.abs(coords[1]) <= 2 * WORLD_RAD) && (coords[0] >= 0) && (coords[1] >= 0)){
			return true
		}
		else{
			return false
		}
	}

	function isWater(type){
		if (type == WATER_BODY_TILE_CODE || type == WATER_BODY_START_TILE_CODE || type == RIVER_TILE_CODE || type == RIVER_START_TILE_CODE){
			return true
		}
		return false
	}

	function isForest(type){
		if (type == FOREST_TILE_CODE || type == FOREST_START_TILE_CODE){
			return true
		}
		return false
	}

	//removed utils here

	function growTile(x, y, cityidx, center = false){
		//we can only grow population... if there is population to grow in the first place
		if (!isTileCity(x, y)){
			return
		}

		if (getTileAt(x, y).basefood == undefined){
			assignTileFood(x, y)
		}

		var thistile = getTileAt(x, y)
		if (center){
			thistile.availfood = thistile.basefood - cities[cityidx].center.population
		}
		else{
			thistile.availfood = thistile.basefood - cities[cityidx].tiles[x + "_" + y].population
		}

		var poptoadd = getNextPopGrowth(thistile.availfood)

		if (center){
			cities[cityidx].center.population += poptoadd
		}
		else{
			cities[cityidx].tiles[x + "_" + y].population += poptoadd
			if (Math.floor(cities[cityidx].tiles[x + "_" + y].population / TILE_POP_STEP) > cities[cityidx].tiles[x + "_" + y].pop_size){
				cities[cityidx].tiles[x + "_" + y].pop_size += 1

				if (cities[cityidx].tiles[x + "_" + y].pop_size > MAX_CITY_TILE_SIZE){
					return
				}

				//var xoff = city_tile_hut_locs[cities[cityidx].tiles[x + "_" + y].pop_size - 1][0]
				//var yoff = city_tile_hut_locs[cities[cityidx].tiles[x + "_" + y].pop_size - 1][1]
				var offsets = getHutOffset(x, y, cities[cityidx].tiles[x + "_" + y].pop_size)
				var xoff = offsets[0]
				var yoff = offsets[1]

				var loader = new THREE.GLTFLoader();

				loader.load('/resources/hut.glb',
					// called when the resource is loaded
					function ( gltf ) {

						gltf.scene.scale.set( 1, 1, 1 );	
						var zoff = getTileAt(x, y).height + base_tile_height

						var finalx = x + xoff
						var finaly = y + yoff

						finalx -= cities[cityidx].tiles[x + "_" + y].mesh.position.x
						finaly -= cities[cityidx].tiles[x + "_" + y].mesh.position.y

						//gltf.scene.position.set(x + xoff, y + yoff, ground_z + zoff)
						gltf.scene.position.set(xoff/2, 0, yoff/2)
						//gltf.scene.position.set(xoff, yoff, zoff / 2)

						//gltf.scene.rotation.x = Math.PI / 2
						gltf.scene.city = true
						gltf.scene.cityID = selectedcityid
						//getTileAt(x, y).add(gltf.scene)
						cities[cityidx].tiles[x + "_" + y].mesh.add(gltf.scene)
						//scene.add( gltf.scene );
					}
				)
			}
		}
	}


	//other game functions
	function center(){
		camera.position.set(camerainitx, camerainity, camerainitz)
		camera.lookAt(camerainitx, camerainity + 5, camerainitz - 5)
	}

	//basic initialization
	var width = window.innerWidth;
	var height = window.innerHeight;
	var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 70 );
	//camera.rotation.order = 'ZYX'
	var renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setSize(width, height);
	document.getElementById('gui').appendChild(renderer.domElement);
	var scene = new THREE.Scene({canvas:gui});
	scene.background = new THREE.Color( 0x191919 );
	scene.add(camera);
	var cameravelocity = new Object()
	cameravelocity.x = 0
	cameravelocity.y = 0
	cameravelocity.z = 0

	var geometry = new THREE.TorusGeometry( 0.5 * Math.sqrt(2, 1/2), 0.02, 8, 4 );
	var material = new THREE.MeshBasicMaterial( { color: 0xaa0000 } );
	var tileoutline = new THREE.Mesh( geometry, material );
	tileoutline.rotation.set(0, 0, Math.PI / 4)
	tileoutline.visible = false
	scene.add( tileoutline );


	/*var composer = new THREE.EffectComposer(renderer)
	var outlinePass = new THREE.OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
	var renderPass = new THREE.RenderPass(scene, camera);

	outlinePass.renderToScreen = true;

	outlinePass.edgeStrength = 2;
	outlinePass.edgeGlow = 1;
	outlinePass.visibleEdgeColor.set(0xffffff);
	outlinePass.hiddenEdgeColor.set(0xffffff);

	composer.addPass(renderPass);
	composer.addPass(outlinePass);*/

	//scene.fog = new THREE.Fog(0x888888, 0, 100)


	//TURN BASED EVENTS AND CHANGES
	function endTurn(){
		//update unit movements
		for (var unit of unitlist){
			unit.m = unit_movements[unit.type]
		}
		if (selectedunitid != 'null'){
			updateUnitBar(selectedunitid)
		}

		//update city populations
		var numcities = cities.length
		for (var cityidx = 0; cityidx < numcities; cityidx++){
			cities[cityidx].people_turns += getTotalPop(cityidx)

			if (cities[cityidx].people_turns >= unit_produce_times[cities[cityidx].producing]){
				if (cities[cityidx].producing == "RB"){
					addRiverboat(cities[cityidx].center.x, cities[cityidx].center.y)
				}

				cities[cityidx].producing = null
				cities[cityidx].people_turns = 0				
			}

			growTile(cities[cityidx].center.x, cities[cityidx].center.y, cityidx, true)
			var numtiles = cities[cityidx].tiles.length
			for (var tile of Object.keys(cities[cityidx].tiles)){
				growTile(cities[cityidx].tiles[tile].x, cities[cityidx].tiles[tile].y, cityidx)
			}
		}

		if (viewing_city_sidebar){
			showCitySidebar(selectedcityid, selectedcitytilex, selectedcitytiley)
		}

		socket.emit('turndone')

		if (multi){
			waitForTurn()
		}
	}

	function checkAndLoad(x, y, explore = true){
		//check the appropriate tiles for being loaded or not
		var tiles_to_check = [
		[x, y],
		[x + LOAD_TERRAIN_DIST, y],
		[x - LOAD_TERRAIN_DIST, y],
		[x, y + LOAD_TERRAIN_DIST],
		[x, y - LOAD_TERRAIN_DIST],
		[x + LOAD_TERRAIN_DIST, y + LOAD_TERRAIN_DIST],
		[x + LOAD_TERRAIN_DIST, y - LOAD_TERRAIN_DIST],
		[x - LOAD_TERRAIN_DIST, y - LOAD_TERRAIN_DIST],
		[x - LOAD_TERRAIN_DIST, y + LOAD_TERRAIN_DIST]
		]
		for (var tile of tiles_to_check){
			var tx = tile[0]
			var ty = tile[1]
			if (getTileAt(tx, ty) == undefined && checkValidTile([tx, ty])){
				//render the correct areas
				fetchAndRender([tx - LOAD_TERRAIN_DIST, ty - LOAD_TERRAIN_DIST], [tx + LOAD_TERRAIN_DIST, ty + LOAD_TERRAIN_DIST])
			}
		}
		// "explore" at the correct areas
		if (explore){
			exploreAtCoords(x, y)
		}
	}


	//STUFF TO CONTROL UNITS 

	var selectedunitid = 'null'
	var selectedcolorfactor = 1.2
	function onMouseClick( event ) {
		if (naming_city){
			return
		}
		var mouse = new THREE.Vector2()
		var raycaster = new THREE.Raycaster();
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		// update the picking ray with the camera and mouse position
		raycaster.setFromCamera( mouse, camera );

		// calculate objects intersecting the picking ray
		var intersects = raycaster.intersectObjects( scene.children, true );


		if (moving_unit){
			//moveUnit()
			//this is the code to move a unit
			//for (var i = 0; i < intersects.length; i++){
			for (var i = 0; i < intersects.length; i++){
				var obj = intersects[i].object
				if (obj.visible != true){
					continue
				}
				if (obj.istile){
					//check if the tile is adjacent
					var initx = unitlist[selectedunitid].mesh.position.x
					var inity = unitlist[selectedunitid].mesh.position.y
					var targetx = obj.position.x
					var targety = obj.position.y


					if (Math.abs(targetx - initx) == 0 && Math.abs(targety - inity) == 0){
						moving_unit = false
						updateUnitBar(selectedunitid)
						break
					}
					if (Math.abs(targetx - initx) > 1){
						break
					}
					if (Math.abs(targety - inity) > 1){
						break
					}
					if (isWater(obj.type) && unitlist[selectedunitid].naval != true){
						break
					}
					if (!isWater(obj.type) && unitlist[selectedunitid].naval == true){
						break
					}
					if (obj.height > MOUNTAIN_STONE_HEIGHT){
						break
					}
					if (tileHasUnit(targetx, targety)){
						break
					}
					if (unitlist[selectedunitid].m == 0){
						break
					}
					else{
						socket.emit('moveunit', selectedunitid, targetx, targety, ground_z + unit_z_offsets[unitlist[selectedunitid].type] + obj.height)

						assignTileUnitStatus(unitlist[selectedunitid].mesh.position.x, unitlist[selectedunitid].mesh.position.y, false)
						assignTileUnitStatus(targetx, targety, true, selectedunitid)

						deActivateTilesAtCenter(unitlist[selectedunitid].mesh.position.x, unitlist[selectedunitid].mesh.position.y)
						activateTilesAtCenter(targetx, targety)

						//hide units that are no longer visible
						for (var xoff = -1; xoff <= 1; xoff++){
							for (var yoff = -1; yoff <= 1; yoff++){
								if (tileHasUnit(unitlist[selectedunitid].mesh.position.x + xoff, unitlist[selectedunitid].mesh.position.y + yoff)){
									if (unitlist[getTileAt(unitlist[selectedunitid].mesh.position.x + xoff, unitlist[selectedunitid].mesh.position.y + yoff).hasUnit_ID].owner == 'self'){
										continue
									}
									if (activetiles.includes((unitlist[selectedunitid].mesh.position.x + xoff) + "," + (unitlist[selectedunitid].mesh.position.y + yoff))){
										continue
									}
									unitlist[getTileAt(unitlist[selectedunitid].mesh.position.x + xoff, unitlist[selectedunitid].mesh.position.y + yoff).hasUnit_ID].mesh.visible = false
								}
							}
						}

						//move the unit
						unitlist[selectedunitid].mesh.position.x = targetx
						unitlist[selectedunitid].mesh.position.y = targety 
						unitlist[selectedunitid].x = targetx
						unitlist[selectedunitid].y = targety
						
						unitlist[selectedunitid].mesh.position.z = ground_z + unit_z_offsets[unitlist[selectedunitid].type] + obj.height
						unitlist[selectedunitid].m -= 1
						checkAndLoad(targetx, targety)

						//check for units on adjacent tile
						for (var xoff = -1; xoff <= 1; xoff++){
							for (var yoff = -1; yoff <= 1; yoff++){
								if (tileHasUnit(targetx + xoff, targety + yoff)){
									unitlist[getTileAt(targetx + xoff, targety + yoff).hasUnit_ID].mesh.visible = true
								}
							}
						}

						//check for cities on adjacent tiles
						checkForAdjacentCities(targetx, targety)
					}
					moving_unit = false

					updateUnitBar(selectedunitid)

					break
				}
			}
			return
		}


		if (!moving_unit && !expanding_city){
			for (var i = 0; i < 1; i++){
				var obj = intersects[i].object
				if (obj.type == "unit" && obj.unitid != selectedunitid){
					if (selectedunitid != 'null'){
						unSelectUnit(selectedunitid)
					}

					if (unitlist[obj.unitid].owner == 'self'){
						selectUnit(obj.unitid)
					}
					else{
						alert("Not your unit!")
					}
				}

				//the object that'll be clicked on will be a portion of a house
				//so the obj.parent will be that house
				//the parent of THAT will be the GLTF/GLB scene
				//so the city property of the parent of the parent of the object will be true
				if (obj.parent != undefined){
					if (obj.parent.parent != undefined){
						if (obj.parent.parent.city == true){
							showCitySidebar(obj.parent.parent.cityID, obj.parent.parent.position.x, obj.parent.parent.position.y)
						}
					}
				}

				//OR, if the user clicks on a tile that has a city:
				if (obj.hasCity == true){
					showCitySidebar(obj.tileCityID, obj.position.x, obj.position.y)
				}

			}
		}
	}

	function exploreAtCoords(x, y){
		x = x * 1
		y = y * 1
		for (var expl_x = -1; expl_x <= 1; expl_x++){
			for (var expl_y = -1; expl_y <= 1; expl_y++){
				newx = x + expl_x
				newy = y + expl_y
				if (checkValidTile([newx, newy]) && !exploredtiles.includes(newx + "," + newy)){

					exploredtiles.push(newx + "," + newy)
					getTileAt(newx, newy).visible = true
				}
			}
		}
	}

	function assignUnitID(obj, id){
		for (var i = 0; i < obj.children.length; i++) {
			var child = obj.children[i];
			assignUnitID(child, id);
			child.unitid = id;
			child.type = "unit"
		}
	}

	function reColorUnit(obj, r, g, b){
		obj.material.emissive.r = r
		obj.material.emissive.g = g
		obj.material.emissive.b = b

		for (var i = 0; i < obj.children.length; i++){
			var child = obj.children[i]
			reColorUnit(child, r, g, b)
			child.material.emissive.r = r
			child.material.emissive.g = g
			child.material.emissive.b = b
		}
	}

	function selectUnit(id){
		for (var child of unitlist[id].mesh.children){
			if (child.material != undefined){
				reColorUnit(child, child.material.emissive.r * selectedcolorfactor, child.material.emissive.g * selectedcolorfactor, child.material.emissive.b * selectedcolorfactor)
			}
		}
		selectedunitid = id
		updateUnitBar(id)
	}

	function unSelectUnit(id){
		for (var child of unitlist[id].mesh.children){
			if (child.material != undefined){
				reColorUnit(child, child.material.emissive.r / selectedcolorfactor, child.material.emissive.g / selectedcolorfactor, child.material.emissive.b / selectedcolorfactor)
			}
		}
		selectedunitid = 'null'
		moving_unit = false
		document.getElementById("unit_desc").style.zIndex = "0"
		document.getElementById("unit_desc").style.display = "none"

		document.getElementById("unit_commands_info").style.zIndex = "0"
		document.getElementById("unit_commands_info").style.display = "none"
	}

	function updateUnitBar(id){
		document.getElementById("unit_desc").style.display = "initial"
		document.getElementById("unit_desc").style.zIndex = "2"
		document.getElementById("unit_desc_name").innerHTML = unit_corresponds[unitlist[id].type]
		if (unitlist[id].n != undefined){
			document.getElementById("unit_desc_name").innerHTML += " (" + unitlist[id].n + ")"	
		}
		document.getElementById("unit_desc_x").innerHTML = "X: " + unitlist[id].x
		document.getElementById("unit_desc_y").innerHTML = "Y: " + unitlist[id].y
		document.getElementById("unit_desc_m").innerHTML = "Movement: " + unitlist[id].m
		if (moving_unit){
			document.getElementById("unit_desc_status").innerHTML = "Status: Moving"
		}
		else{
			document.getElementById("unit_desc_status").innerHTML = "Status: Idling"
		}

		document.getElementById("unit_commands_info").style.display = "initial"
		document.getElementById("unit_commands_info").style.zIndex = "2"
		document.getElementById("unit_specific_commands").innerHTML = unit_commands[unitlist[id].type]
	}

	function showLoadingScreen(){
		document.getElementById("loadingscreen").style.display = "initial"
	}

	function hideLoadingScreen(){
		document.getElementById("loadingscreen").style.display = "none"
	}

	function waitForTurn(){
		document.getElementById("loadingscreen").style.display = "initial"
	}

	function activateTilesAtCenter(x, y){
		x = x * 1
		y = y * 1
		for (var xoff = -1; xoff <= 1; xoff++){
			for (var yoff = -1; yoff <= 1; yoff++){
				var tile = (x + xoff) + "," + (y + yoff)
				if (!activetiles.includes(tile)){
					activetiles.push(tile)
				}
			}
		}
	}

	function deActivateTilesAtCenter(x, y){
		x = x * 1
		y = y * 1
		for (var xoff = -1; xoff <= 1; xoff++){
			for (var yoff = -1; yoff <= 1; yoff++){
				if (isTileAdjacentToSelfCity(x + xoff, y + yoff)){
					continue
				}
				activetiles.splice(activetiles.indexOf((x + xoff) + "," + (y + yoff)), 1)
			}
		}
	}


	//CITY STUFF

	var viewing_city_sidebar = false
	var selectedcityid = 'null'
	var selectedcitytilex = 'null'
	var selectedcitytiley = 'null'
	//var tileoutline = 'null'

	var in_city_tile_view = false
	var redirecting_food = false

	function reAssignFood(coords1, coords2, amount){
		getTileAt(coords1[0], coords1[1]).basefood -= amount
		getTileAt(coords2[0], coords2[1]).basefood += amount
	}

	function redirectFood(tileobj = ''){
		if (!in_city_tile_view){
			showCityTileView()
		}
		if (!redirecting_food){
			redirecting_food = true
			return
		}
		else{
			if (tileobj == ''){
				return
			}
			else{
				var split = tileobj.id.split("_")
				var targetx = split[2] * 1
				var targety = split[3] * 1
				assignTileFood(selectedcitytilex, selectedcitytiley)
				assignTileFood(targetx, targety)

				var redirectval = document.getElementById("foodRedirectTextInput").value
				if (isNaN(redirectval)){
					return
				}

				redirectval = redirectval * 1

				if (redirectval < 1){
					return
				}

				if (getTileAt(selectedcitytilex, selectedcitytiley).basefood - redirectval < mincitytilepop){
					alert("Too much food to redirect! You need to leave 50 food on each tile.")
					return
				}

				//getTileAt(selectedcitytilex, selectedcitytiley).basefood -= redirectval
				//getTileAt(targetx, targety).basefood += redirectval
				reAssignFood([selectedcitytilex, selectedcitytiley], [targetx, targety], redirectval)
				redirecting_food = false

				showCitySidebar(selectedcityid, selectedcitytilex, selectedcitytiley)

				socket.emit('redirectfood', selectedcitytilex, selectedcitytiley, targetx, targety, redirectval)
			}
		}
	}

	function showCityTileView(argCityID = selectedcityid){
		in_city_tile_view = true
		var tilescreen = document.getElementById("city_tile_view_screen")
		tilescreen.textContent = ''
		tilescreen.style.zIndex = "2"
		tilescreen.style.display = "initial"

		var this_city = cities[argCityID]
		var this_city_x = this_city.center.x
		var this_city_y = this_city.center.y

		var windowheight = tilescreen.clientHeight
		var windowwidth = tilescreen.clientWidth

		//render the city center
		var tiles = Object.keys(this_city.tiles)
		var centertile = this_city_x + "_" + this_city_y
		tiles.push(centertile)

		for (var citytile of tiles){
			var tile = document.getElementById("tiletemplate")
			var tile_clone = tile.cloneNode(true)
			if (citytile == centertile){
				var x = 0
				var y = 0
			}
			else{
				var x = this_city.tiles[citytile].x - this_city_x
				var y = this_city.tiles[citytile].y - this_city_y
			}

			tile_clone.id = this_city.cityID + "_" + this_city.name + "_" + (x + this_city_x) + "_" + (y + this_city_y)

			y = -y
			tile_clone.style.position = "fixed"
			tile_clone.style.zIndex = 2
			tile_clone.style.top = (y*100 + Math.round(windowheight / 2)) + "px"
			tile_clone.style.left = (x*100 + Math.round(windowwidth / 2)) + "px"
			tile_clone.style.border = "1px solid white"

			//get the color of the tile
			if (x == 0 && y == 0){
				tile_clone.style.backgroundColor = "rgb(140, 20, 20)"
			}
			else{
				var col = getTileAt(this_city.tiles[citytile].x, this_city.tiles[citytile].y).material.color
				var r = Math.round(col.r * 255)
				var g = Math.round(col.g * 255)
				var b = Math.round(col.b * 255)

				tile_clone.style.backgroundColor = "rgb(" + r + ", " + g + ", " + b + ")"
			}

			document.getElementById("city_tile_view_screen").appendChild(tile_clone)
		}
	}

	function selectTileFromTileView(obj){
		if (redirecting_food){
			redirectFood(obj)
			return
		}
		//alert("here")
		var split = obj.id.split("_")
		var x = split[2] * 1
		var y = split[3] * 1
		var id = split[0] * 1
		showCitySidebar(id, x, y)
	}

	function hideCityTileView(){
		in_city_tile_view = false
		document.getElementById("city_tile_view_screen").style.zIndex = "0"
		document.getElementById("city_tile_view_screen").style.display = "none"
	}


	function breakCity(){
		var targetpop = 100
		//check if there is enough population to break off into people

		if (tileHasUnit(selectedcitytilex, selectedcitytiley)){
			return
		}

		//first check if we are at the city center
		if (isCityCenter(selectedcityid, selectedcitytilex, selectedcitytiley)){
			var population = cities[selectedcityid].center.population
			if (population - targetpop < mincitytilepop){
				alert("Not enough population!")
				return
			}
			cities[selectedcityid].center.population -= targetpop
		}
		else{
			var population = cities[selectedcityid].tiles[selectedcitytilex + "_" + selectedcitytiley].population
			if (population - targetpop < mincitytilepop){
				alert("Not enough population!")
				return
			}
			cities[selectedcityid].tiles[selectedcitytilex + "_" + selectedcitytiley].population -= targetpop
		}

		showCitySidebar(selectedcityid, selectedcitytilex, selectedcitytiley)
		addPeople(selectedcitytilex, selectedcitytiley)
	}


	function expandCity(dir, argx='', argy='', argid='', self = true){
		var x = argx
		var y = argy
		var id = argid

		if (isNaN(argx) || isNaN(argy) || isNaN(argid) || argx === '' || argy === '' || argid === ''){
			var x = selectedcitytilex
			var y = selectedcitytiley
			var id = selectedcityid
		}

		var targetx = x + (1*dir[0])
		var targety = y + (1*dir[1])
		var targetpop = 50

		//ensure that tile is valid
		if (!checkValidTile([targetx, targety])){
			return
		}

		//if self, tile must be explored
		if (!exploredtiles.includes(targetx + "," + targety) && self){
			return
		}

		//ensure that the tile is not water
		if (isWater(grid_dict["tile_" + targetx + "_" + targety].type)){
			return
		}

		//ensure that the tile is not too high up
		if (getTileAt(targetx, targety).height > MOUNTAIN_STONE_HEIGHT){
			return
		}

		//check if tile is already in current city
		//(cities[selectedcityid].center.x == targetx && cities[selectedcityid].center.y == targety)
		if (isCityCenter(id, targetx, targety) || cities[id].tiles[targetx + "_" + targety] != undefined){
			return
		}

		//check if tile is in another city
		if (isTileCity(targetx, targety)){
			return
		}

		//ensure that there is enough population for expansion to occur
		//first check for city center
		if (isCityCenter(id, x, y)){
			if (cities[id].center.population - targetpop < mincitytilepop){
				alert("Not enough population to expand!")
				return
			}
			cities[id].center.population -= targetpop
		}
		else{
			//and now check for other tiles
			if (cities[id].tiles[x + "_" + y].population - targetpop < mincitytilepop){
				alert("Not enough population to expand!")
				return
			}
			cities[id].tiles[x + "_" + y].population -= targetpop
		}

		cities[id].tiles[targetx + "_" + targety] = new Object()

		var loader = new THREE.GLTFLoader();

		loader.load('/resources/hut.glb',
			// called when the resource is loaded
			function ( gltf ) {

				gltf.scene.scale.set( 2, 2, 2 );	
				var zoff = getTileAt(targetx, targety).height + base_tile_height
				gltf.scene.position.set(targetx, targety, ground_z + zoff)

				assignCity(targetx, targety, id)

				gltf.scene.rotation.x = Math.PI / 2
				gltf.scene.city = true
				gltf.scene.cityID = id
				gltf.scene.visible = false

				if (activetiles.includes(targetx + "," + targety) || self){
					gltf.scene.visible = true
				}

				scene.add( gltf.scene );

				cities[id].tiles[targetx + "_" + targety].x = targetx
				cities[id].tiles[targetx + "_" + targety].y = targety
				cities[id].tiles[targetx + "_" + targety].mesh = gltf.scene
				cities[id].tiles[targetx + "_" + targety].population = 50
				cities[id].tiles[targetx + "_" + targety].pop_size = 1

				if (self){
					activateTilesAtCenter(targetx, targety)
				}

				if (in_city_tile_view){
					showCityTileView(id)
				}

				assignTileFood(targetx, targety)
			}
		)

		var tile = getTileAt(targetx, targety)
		var l = tile.children.length
		for (var i = 0; i < l; i++){
			if (tile.children[0].tree == true){
				tile.children.pop(0)
			}
		}

		checkAndLoad(targetx, targety, self)

		if (self){
			showCitySidebar(id, x, y)
			checkForAdjacentCities(targetx, targety)
		}

		if (self){
			socket.emit('expandcity', dir[0], dir[1], x, y, id)
		}
		//exploreAtCoords(targetx, targety)
	}


	function getTotalPop(cityID){
		var pop = 0

		pop += cities[cityID].center.population

		for (var tile of Object.keys(cities[cityID].tiles)){
			pop += cities[cityID].tiles[tile].population
		}

		return pop
	}

	function changeCityProduction(){
		if (isNaN(selectedcityid) || selectedcityid === ''){
			return
		}
		cities[selectedcityid].producing = document.getElementById("select_unit_to_produce").value
		cities[selectedcityid].people_turns = 0

		showCitySidebar(selectedcityid, selectedcitytilex, selectedcitytiley)
	}


	var city_x_offset = 0
	var cities = []
	var citynames = []
	var naming_city = false
	var current_city = ''
	function buildCity(id, name=''){
		if (id == 'null'){
			return
		}
		if (unitlist[id].type != "P"){
			return
		}
		if (unitlist[id].m <= 0){
			return
		}

		var already_named = false
		if (name != ''){
			if (name.length > 20){
				return
			}
			else{
				already_named = true
			}
		}

		var cityx = unitlist[id].x * 1
		var cityy = unitlist[id].y * 1

		if (isTileCity(cityx, cityy)){
			return
		}

		var citypop = unitlist[id].n * 1


		naming_city = true
		if (already_named){
			naming_city = false
		}

		scene.remove(unitlist[id].mesh)

		assignTileUnitStatus(cityx, cityy, false)

		//keep this id temporarily since both pop and unselect will get rid of it
		var temp_id = id

		unSelectUnit(temp_id)

		unitlist[temp_id] = 'removed'

		var this_city = new Object()
		this_city.center = new Object()

		if (isTileAdjacentToWater(cityx, cityy)){
			this_city.coastal = true
		}
		else{
			this_city.coastal = false
		}

		this_city.producing = null
		this_city.people_turns = 0

		var loader = new THREE.GLTFLoader();

		loader.load('/resources/city_center.glb',
			// called when the resource is loaded
			function ( gltf ) {

				gltf.scene.scale.set( 2, 2, 2 );	
				var zoff = getTileAt(cityx, cityy).height + base_tile_height
				gltf.scene.position.set(cityx + city_x_offset, cityy, ground_z + zoff)
				gltf.scene.cityID = cities.length

				assignCity(cityx, cityy, cities.length)

				gltf.scene.rotation.x = Math.PI / 2
				gltf.scene.city = true
				gltf.scene.visible = false

				if (activetiles.includes(cityx + "," + cityy)){
					gltf.scene.visible = true
				}

				scene.add( gltf.scene );

				this_city.center.mesh = gltf.scene

				if (already_named){
					citynames.push(name)
					this_city.name = name
					this_city.center.mesh.cityname = name
					this_city.cityID = cities.length
					cities.push(this_city)
				}

				assignTileFood(cityx, cityy)

				//activateTilesAtCenter(cityx, cityy)
			}
		)

		var tile = getTileAt(cityx, cityy)
		var l = tile.children.length
		for (var i = 0; i < l; i++){
			if (tile.children[0].tree == true){
				tile.children.pop(0)
			}
		}

		this_city.center.x = cityx
		this_city.center.y = cityy
		this_city.center.population = citypop

		this_city.tiles = new Object()

		current_city = this_city

		if (already_named){
			this_city.owner = 'notself'
		}
		if (!already_named){
			this_city.owner = 'self'
			showCityNamePanel(id)
		}
	}


	unitlist = []

	function drawUnits(i, emit = true){
		//for (var i = 0; i < units.length; i++){
			if (units[i] == ''){
				return
			}
			if (emit){
				socket.emit('unitcreated', units[i])
			}
			var info = units[i].split("~")
			var unittype = info[0]
			var unitinfo = info[1].split(",")
			var thisunit = {}
			thisunit.unitid = i
			thisunit.type = unittype
			for (var keyvalpair of unitinfo){
				var spl = keyvalpair.split(":")
				var key = spl[0]
				var val = spl[1]
				thisunit[key] = val
			}

			if (emit){
				thisunit.owner = 'self'
				activateTilesAtCenter(thisunit.x, thisunit.y)
			}
			else{
				thisunit.owner = 'notself'
			}

			unitlist.push(thisunit)
			assignTileUnitStatus(thisunit.x, thisunit.y, true, i)
			if (activetiles.includes(thisunit.x + "," + thisunit.y)){
				var vis = true
			}
			else{
				var vis = false
			}


			if (unittype == "P"){
				//fetchAndRender([thisunit.x * 1, thisunit.y * 1], [thisunit.x*1 + 1, thisunit.y*1 + 1])
				drawPeople(thisunit.x, thisunit.y, thisunit.unitid, vis)
			}
			if (unittype == "RB"){
				drawRiverboat(thisunit.x, thisunit.y, thisunit.unitid, vis)
			}
		//}
	}

	function addPeople(x, y){
		//console.log(units)
		units.push(people_template.replace("xhere", x).replace("yhere", y))
		drawUnits(units.length - 1)
	}

	function drawPeople(x, y, id, vis = true){

		var col = new THREE.Color(0.4, 0.4, 0.4)//0.6, 0, 0.8)

		var loader = new THREE.GLTFLoader();

		loader.load('/resources/people.glb',
			// called when the resource is loaded
			function ( gltf ) {

				gltf.scene.scale.set( 1, 1, 1 );	

				gltf.scene.position.set(x, y, ground_z + 1)

				//gltf.scene.children[2].position = new THREE.Vector3(x, y, ground_z + 1)

				//gltf.scene.rotation.x = Math.PI / 2
				var people = gltf.scene//.children[2]
				scene.add( people );

				var hoffset = getTileAt(x, y).height

				people.position.set(x, y, ground_z + hoffset + 1)
				people.rotation.set(Math.PI / 2, 0, 0)

				people.type = "unit"

				people.visible = vis
				assignUnitID(people, id)
				//people.unitid = id

				unitlist[id].mesh = people
				unitlist[id].naval = false

				//modify explored tiles
				if (vis){
					exploreAtCoords(x, y)
				}
			}
		)

		//get the height of the tile and offset the unit by that
		if (getTileAt(x, y) == undefined){
			console.log(x, y)
		}

	}


	function addRiverboat(x, y){
		units.push(riverboat_template.replace("xhere", x).replace("yhere", y))
		drawUnits(units.length - 1)
	}

	function drawRiverboat(x, y, id, vis = true){

		var col = new THREE.Color(0.4, 0.4, 0.4)//0.6, 0, 0.8)

		var loader = new THREE.GLTFLoader();

		loader.load('/resources/riverboat.glb',
			// called when the resource is loaded
			function ( gltf ) {

				gltf.scene.scale.set( 0.07, 0.07, 0.07 );	

				gltf.scene.position.set(x, y, ground_z + 0.2)

				//gltf.scene.children[2].position = new THREE.Vector3(x, y, ground_z + 1)

				//gltf.scene.rotation.x = Math.PI / 2
				var boat = gltf.scene//.children[2]
				scene.add( boat );

				var hoffset = getTileAt(x, y).height

				boat.position.set(x, y, ground_z + hoffset + 0.2)
				boat.rotation.set(Math.PI / 2, Math.PI / 2, 0)

				boat.type = "unit"

				boat.visible = vis
				assignUnitID(boat, id)
				//people.unitid = id

				unitlist[id].mesh = boat
				unitlist[id].naval = true

				//modify explored tiles
				if (vis){
					exploreAtCoords(x, y)
				}
			}
		)

		//get the height of the tile and offset the unit by that
		if (getTileAt(x, y) == undefined){
			console.log(x, y)
		}

	}


	//TILE FETCHING AND DRAWING CODE

	function fetchAndRender(coords1, coords2){
		for (var y = coords1[1]; y < coords2[1]; y++){
			for (var x = coords1[0]; x < coords2[0]; x++){
				var req = new XMLHttpRequest;
				req.open("GET", "/gettile?x=" + x + "&y=" + y + "&file=" + FILE)
				req.send()
				req.onreadystatechange = function(){
					if (this.readyState == 4 && this.status == 200){
						var r = this.responseText.replace("[", '').replace("]", '')
						r = r.replace("{", '').replace("}", '').split('","')
						r[0] = r[0].split(":")[1].replaceAll('"', '')
						r[1] = r[1].split(":")[1].replaceAll('"', '')
						var x = r[0].split("_")[0] * 1
						var y = r[0].split("_")[1] * 1
						draw(x, y, r[1])
					}
				}
			}
		}
	}

	//draw the terrain
	//function draw(coords1, coords2, data){
	function draw(x, y, data){
		if (getTileAt(x, y) != undefined){
			return
		}
		//var tiledata = data[y % 100][x % 100].split("#")[1]
		//var height = data[y % 100][x % 100].split("#")[0] * 1
		var tiledata = data.split(HEIGHT_DELIMITER)[1]
		var height = data.split(HEIGHT_DELIMITER)[0] * 1
		var type = tiledata.split(INFO_DELIMITER)[0]
		var forest = false

		if (type == LAND_TILE_CODE){
			col = getLandCol(x, y)
		}

		if (isWater(type)){
			col = getWaterCol(x ,y)
		}

		if (type == FOREST_TILE_CODE || type == FOREST_START_TILE_CODE){
			forest = true;
			treestodraw = tiledata.split("|")[1] * 1
			col = getForestCol(x, y)
		}

		if (height == 0 && isWater(type)){
			var geometry = new THREE.PlaneGeometry( 1, 1 );
		}
		else if (height == 0 && !isWater(type)){
			height = height + base_tile_height
			var geometry = new THREE.BoxGeometry(1, 1, height)
		}
		else{
			height = height + base_tile_height
			var geometry = new THREE.BoxGeometry(1, 1, height)
			var heightmod = 1 - height/5
			var mincolormtn = 0.2

			if (height > MOUNTAIN_FOREST_HEIGHT){
				col = getForestCol(x, y)
			}
			for (var it = 0; it < height - 2; it++){
				col.r = col.r + (mincolormtn - col.r) / 2
				col.g = col.g + (mincolormtn - col.g) / 2
				col.b = col.b + (mincolormtn - col.b) / 2
			}
			if (height > MOUNTAIN_STONE_HEIGHT){
				col = getStoneCol(x, y)
			}
			if (height > MOUNTAIN_SNOWCAP_HEIGHT && height <= MOUNTAIN_SNOW_HEIGHT){
				var faces = geometry.faces
				for (var face of faces){
					if (face.normal.z == 1){
						face.color.set(getSnowCol(x, y))
					}
					else{
						face.color.set(col)
					}
				}
				geometry.colorsNeedUpdate = true;//col = getSnowCol()
			}
			if (height > MOUNTAIN_SNOW_HEIGHT){
				col = getSnowCol(x, y)
			}
		}
		geometry = new THREE.BufferGeometry().fromGeometry(geometry)

		var tilematerial = new THREE.MeshBasicMaterial( {color: col, vertexColors: THREE.FaceColors } )//, side: THREE.DoubleSide} );
		var plane = new THREE.Mesh( geometry, tilematerial );
		plane.istile = true
		plane.type = type
		plane.height = height - base_tile_height
		plane.name = "tile_" + x + "_" + y
		grid_dict["tile_" + x + "_" + y] = plane

		plane.position.set(x, y, ground_z + height/2)

		plane.lookAt(x, y, 50)
		scene.add(plane);

		if (forest){
			for (var treegen = 0; treegen < treestodraw; treegen++){
				drawTree([x, y], height, 1)
				drawTree([x, y], height, 2)
				drawTree([x, y], height, 3)
			}
		}

		var treeprob = 324 * WORLD_SEED / (x * y / 23)
		treeprob = (treeprob % 40) / 40

		if (treeprob > 0.9 && type == 'l') {
			drawTree([x, y], height, 1)
			//drawTree([x, y], height)
		}

		if (exploredtiles.includes(x + "," + y)){
		}
		else{
			plane.visible = false
		}
	}


	document.onkeypress = function (e) {
		if (naming_city){
			return
		}
		var code = e.keyCode
		var letter = String.fromCharCode(code)
		if (letter == 'c'){
			center()
			return
		}
		if (letter == 's'){
			if (cameralooking == 'front'){
				camera.lookAt(camera.position.x, camera.position.y - 5, camera.position.z - 5)
				camera.position.y += 10
				camera.rotateOnAxis(new THREE.Vector3(0, 0, 1), Math.PI)
				cameralooking = 'back'
			}
		}
		if (letter == 'w'){
			if (cameralooking == 'back'){
				camera.lookAt(camera.position.x, camera.position.y + 5, camera.position.z - 5)
				camera.position.y -= 10
				//camera.rotateOnAxis(new THREE.Vector3(0, 0, 1), Math.PI)
				cameralooking = 'front'
			}
		}
		if (letter == 'z'){
			camera.position.z -= 0.2
		}

		if (letter == 'g' && selectedunitid != 'null'){
			moving_unit = true
			updateUnitBar(selectedunitid)
		}

		if (letter == 'b' && selectedunitid != 'null'){
			if (unitlist[selectedunitid].type == "P"){
				buildCity(selectedunitid)
			}
		}

		if (letter == 'v' && selectedcityid != "null"){
			showCityTileView(selectedcityid)
		}
	};

	document.onkeydown = function(e) {
		if (naming_city){
			return
		}
		var cameramovement = 0.5
		var code = e.keyCode
		var realign = false;
		var velcap = 5
		if (cameralooking == 'back'){
			cameramovement *= -1
		}

		if (code == esckeycode){
			if (selectedunitid != "null"){
				unSelectUnit(selectedunitid)
				return
			}
			if (in_city_tile_view){
				hideCityTileView()
				return
			}
			if (viewing_city_sidebar){
				hideCitySidebar()
				return
			}
		}

		if (code == endturnkeycode){//enterkeycode){
			endTurn()
		}

		if (code == leftarrowcode){
			cameravelocity.x -= cameramovement
			//camera.position.x -= cameramovement
			realign = true
		}
		if (code == rightarrowcode){
			cameravelocity.x += cameramovement
			//camera.position.x += cameramovement
			realign = true
		}
		if (code == uparrowcode){
			cameravelocity.y += cameramovement
			//camera.position.y += cameramovement
			realign = true
		}
		if (code == downarrowcode){
			cameravelocity.y -= cameramovement
			//camera.position.y -= cameramovement
			realign = true
		}

		if (code == spacekeycode){
			camera.position.z += 0.2
		}

		if (cameravelocity.x > velcap){
			cameravelocity.x = velcap
		}
		if (cameravelocity.y > velcap){
			cameravelocity.y = velcap
		}
		if (cameravelocity.x < -velcap){
			cameravelocity.x = -velcap
		}
		if (cameravelocity.y < -velcap){
			cameravelocity.y = -velcap
		}
		if (realign){
			//controls.target = new THREE.Vector3(camera.position.x, camera.position.y - camerainity, camera.position.z - camerainitz)
		}
	}

	function animate() {
		var xcammod = cameravelocity.x * 0.1
		var ycammod = cameravelocity.y * 0.1
		camera.position.x += xcammod
		camera.position.y += ycammod


		cameravelocity.x += (-cameravelocity.x) * 0.1
		cameravelocity.y += (-cameravelocity.y) * 0.1

		//controls.update();
		renderer.render( scene, camera );
		requestAnimationFrame( animate );

		updateCityLabels()
	}

	var done_init = false
	function initialize(centerx, centery, spawnlocs){

		activateTilesAtCenter(centerx, centery)

		gamecenterx = centerx
		gamecentery = centery

		camerainitx = gamecenterx
		camerainity = gamecentery - 5
		camerainitz = 5

		camera.position.set(camerainitx, camerainity, camerainitz)

		var filereq = new XMLHttpRequest;

		if (multi){
			var room = window.location.href.split("/").slice(-1)
			filereq.open("GET", "/gamefile/" + room)
		}
		else{
			filereq.open("GET", "/numsaves")
		}

		filereq.send()
		filereq.onreadystatechange = function(){
			if (this.readyState == 4 && this.status == 200){

				if (multi){
					FILE = this.responseText
				}
				else{
					//FILE = "map" + String(Math.ceil(Math.random() * (this.responseText * 1)))
				}

				var seedreq = new XMLHttpRequest;
				seedreq.open("GET", "/seed?file=" + FILE)
				seedreq.send()

				seedreq.onreadystatechange = function(){
					if (this.readyState == 4 && this.status == 200){
						WORLD_SEED = this.responseText * 1


						/*var explreq = new XMLHttpRequest;
						explreq.open("GET", "/explored?file=" + FILE)
						explreq.send()*/

						//explreq.onreadystatechange = function(){
							//if (this.readyState == 4 && this.status == 200){
								exploredtiles = centerx + "," + centery //this.responseText
								exploredtiles = exploredtiles.split("\n")

								for (var expltile of exploredtiles){
									var tx = expltile.split(",")[0] * 1
									var ty = expltile.split(",")[1] * 1
									//checkAndLoad(tx, ty)
									fetchAndRender([tx - 2, ty - 2], [tx + 3, ty + 3])
								}

								//fetchAndRender([gamecenterx - 3, gamecentery - 3], [gamecenterx + 3, gamecentery + 3])

								if (multi){
									for (var loc of spawnlocs){
										var nloc = loc.split(",")
										//checkAndLoad(nloc[0]*1, nloc[1]*1)
										fetchAndRender([nloc[0]*1 - 1, nloc[1]*1 - 1], [nloc[0]*1 + 2, nloc[1]*1 + 2])
									}
								}

								var unitreq = new XMLHttpRequest;
								unitreq.open("GET", "/units?file=" + FILE)
								setTimeout( function(){unitreq.send()}, 2000 )

								unitreq.onreadystatechange = function(){
									if (this.readyState == 4 && this.status == 200){
										let init_ind = units.length
										if (init_ind < 0){
											init_ind = 0
										}
										let temp = this.responseText
										temp = temp.split("\n")
										temp.pop()
										temp[0] = temp[0].replace("xhere", centerx).replace("yhere", centery)
										units.push(...temp)
										//console.log(temp, units)
										for (var i = 0; i < units.length; i++){
											//console.log(i)
											if (i < init_ind){
												drawUnits(i, false)
											}
											else{
												drawUnits(i, true)
											}
										}
										endTurn()
										if (!multi){
											hideLoadingScreen()
										}
									}
								}			
							//}
						//}
					}
				}
			}
		}


		window.addEventListener( 'click', onMouseClick, false );
		//fetchAndRender([100, 0])


		camera.lookAt(camerainitx, camerainity + 5, camerainitz - 5)

		//renderer.gammaOutput = true


		animate();
	}



	if (!multi){
		var filereq = new XMLHttpRequest;
		filereq.open("GET", "/numsaves")
		filereq.send()
		filereq.onreadystatechange = function(){
			if (this.readyState == 4 && this.status == 200){
				FILE = "map" + String(Math.ceil(Math.random() * (this.responseText * 1)))
				var spawnlocreq = new XMLHttpRequest;
				spawnlocreq.open("GET", "/spawnlocsbyfile/" + FILE)
				spawnlocreq.send()
				spawnlocreq.onreadystatechange = function(){
					if (this.readyState == 4 && this.status == 200){
						var locs = this.responseText.split("\n")
						loc = locs[0]
						loc = loc.split(",")
						let x = loc[0] * 1
						let y = loc[1] * 1
						initialize(x, y, locs)
					}
				}
			}
		}
	}
	//initialize()


	//SOCKET HANDLING AND SUCH
	socket.on('whoareyou', function(){
		socket.emit('i_am', GAMEID)
	})

	socket.on('yourturn', function(playernum){
		if (!done_init){
			var room = window.location.href.split("/").slice(-1)
			var spawnlocreq = new XMLHttpRequest;
			spawnlocreq.open("GET", "/spawnlocs/" + room)
			spawnlocreq.send()
			spawnlocreq.onreadystatechange = function (){
				if (this.readyState == 4 && this.status == 200){
					var locs = this.responseText.split("\n")
					locs.pop()
					//console.log(locs)
					loc = locs[playernum]
					loc = loc.split(",")
					let x = loc[0] * 1
					let y = loc[1] * 1
					initialize(x, y, locs)
					done_init = true
				}
			}
		}
		else{
			hideLoadingScreen()
		}
		//myturn = true
	})


	var ending_game = false
	socket.on('endgame', function(){
		if (ending_game){
			return
		}
		ending_game = true
		setTimeout(function(){
			window.location.replace("/")
		}, 2000)
		alert("A player left the game. Ending game, redircting back home...")
	})

	//SOCKET GAME MECHANICS
	socket.on('unitcreated', function(unit){
		//console.log("here", unit)
		units.push(unit)
		if (done_init){
			drawUnits(units.length - 1, false)
		}
	})

	socket.on('moveunit', function(id, x, y, z){
		if (id > unitlist.length - 1){
			return
		}

		checkAndLoad(x, y, false)

		//if (exploredtiles.includes(unitlist[id].mesh.position.x + "," + unitlist[id].mesh.position.y)){
		assignTileUnitStatus(unitlist[id].mesh.position.x, unitlist[id].mesh.position.y, false)
		//}

		//if (exploredtiles.includes(x + "," + y)){
		assignTileUnitStatus(x, y, true, id)
		//}
		unitlist[id].mesh.position.set(x, y, z)
		unitlist[id].x = x * 1
		unitlist[id].y = y * 1

		if (activetiles.includes(x + "," + y)){
			unitlist[id].mesh.visible = true
		}
		else{
			unitlist[id].mesh.visible = false
		}
	})

	socket.on('buildcity', function(id, name){
		buildCity(id, name)
	})

	socket.on('expandcity', function(dir0, dir1, x, y, id){
		expandCity([dir0, dir1], x, y, id, false)
	})

	socket.on('redirectfood', function(x1, x2, y1, y2, amt){
		reAssignFood([x1*1, y1*1], [x2*1, y2*1], amt*1)
	})

</script>

</html>
